var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SortedIteratorProducts","category":"page"},{"location":"#SortedIteratorProducts","page":"Home","title":"SortedIteratorProducts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SortedIteratorProducts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SortedIteratorProducts]","category":"page"},{"location":"#SortedIteratorProducts.SortedIteratorProduct-Tuple{Function, Vararg{Any}}","page":"Home","title":"SortedIteratorProducts.SortedIteratorProduct","text":"SortedIteratorProduct(by::Function, iterators...)\n\nConstruct an iterator over the cartesian product of iterators that is sorted according to by. by must be non-decreasing over the indices of iterators.\n\nFor example, if there are two iterators a and b, then by(first(a), first(b)) â‰¤ by(first(a), second(b)) where second(b) is the second element of b.\n\njulia> using ..SortedIteratorProducts, Base.Iterators\n\njulia> A = Iterators.Count(1, 1)\nBase.Iterators.Count{Int64, Int64}(1, 1)\n\njulia> B = Iterators.Count(3, 2)\nBase.Iterators.Count{Int64, Int64}(3, 2)\n\njulia> x = SortedIteratorProduct(sum, A, B);\n\njulia> collect(take(x, 6))\n6-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (2, 3)\n (3, 3)\n (1, 5)\n (4, 3)\n (2, 5)\n\njulia> x = SortedIteratorProduct(((b,a),) -> b^a, B, A);\n\njulia> collect(take(x, 6))\n6-element Vector{Tuple{Int64, Int64}}:\n (3, 1)\n (5, 1)\n (7, 1)\n (9, 1)\n (3, 2)\n (11, 1)\n\n\n\n\n\n","category":"method"}]
}
